#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

WIDTH=80
HEIGHT=40
CONFIG_DIR="$HOME/.config"
DOTFILES_DIR="$HOME/devenv"
PACKAGE_MANAGER="paru"
PACKAGES_JSON="$DOTFILES_DIR/packages.json"
PACKAGES_LOCK="$DOTFILES_DIR/packages-lock.json"
SUDO_PASS=""
TMP_OUTPUT="/tmp/package-install-output.log"

main() {
    trap 'cleanup' INT TERM
    dialog_box
    clear
    exit 0
}

cleanup() {
    clear
    printf "Script interrupted or terminated\n" >&2
    exit 1
}

get_sudo_password() {
    local pass
    while true; do
        pass=$(dialog --insecure --passwordbox "Enter sudo password" "$HEIGHT" "$WIDTH" 2>&1 >/dev/tty)
        if [[ -z "${pass// /}" ]]; then
            dialog --title "Authentication Failed" --msgbox "Password required" "$HEIGHT" "$WIDTH"
            clear
            exit 1
        fi
        if echo "$pass" | sudo -S -v &>/dev/null; then
            export SUDO_PASS="$pass"
            break
        else
            dialog --title "Authentication Failed" --msgbox "Incorrect password. Try again." "$HEIGHT" "$WIDTH"
        fi
    done
}

run_with_sudo() {
    if [[ -z "${SUDO_PASS:-}" ]]; then
        get_sudo_password
    fi
    printf '%s\n' "$SUDO_PASS" | sudo -S "$@"
}

validate_package_exists() {
    local name="$1"
    if pacman -Si "$name" &>/dev/null; then
        return 0
    fi
    if command -v paru &>/dev/null && paru -Si "$name" &>/dev/null; then
        return 0
    fi
    dialog --title "Validation Failed" --msgbox "Package '$name' not found in any repositories." "$HEIGHT" "$WIDTH"
    return 1
}

install_package() {
    local pkg="$1"
    local fallback_to_pacman=false

    if [[ "$PACKAGE_MANAGER" == "paru" ]] && command -v paru &>/dev/null; then
        if ! paru -S --needed --noconfirm "$pkg" >>"$TMP_OUTPUT" 2>&1; then
            fallback_to_pacman=true
        fi
    else
        fallback_to_pacman=true
    fi

    if $fallback_to_pacman; then
        if ! pacman -S --needed --noconfirm "$pkg" >>"$TMP_OUTPUT" 2>&1; then
            return 1
        fi
    fi

    return 0
}

show_main_menu() {
    local choice
    choice=$(dialog --title "Linux system" \
        --cancel-label "Exit" \
        --menu "Choose an option" "$HEIGHT" "$WIDTH" 0 \
        1 "Packages" \
        2 "Symlink dotfiles" \
        3 "Initialize packages.json" \
        2>&1 >/dev/tty)
    local status=$?
    if [[ $status -eq 1 ]]; then clear; exit 0; fi
    case "$choice" in
        1) show_package_menu ;;
        2) link_dotfiles ;;
        3) init_packages ;;
    esac
}

show_package_menu() {
    local option
    option=$(dialog --title "Package Menu" \
        --extra-button --extra-label "Go Back" \
        --cancel-label "Exit" \
        --menu "Choose a package operation" "$HEIGHT" "$WIDTH" 0 \
        1 "Add packages" \
        2 "Install packages" \
        3 "Delete packages" \
        4 "Update lockfile" \
        5 "Clean system" \
        2>&1 >/dev/tty)
    local status=$?
    if [[ $status -eq 3 ]]; then show_main_menu; return; fi
    if [[ $status -eq 1 ]]; then clear; exit 0; fi
    case "$option" in
        1) add_package ;;
        2) install_packages ;;
        3) delete_package ;;
        4) update_lock ;;
        5) clean_packages ;;
    esac
}

add_package() {
    while true; do
        local package
        package=$(dialog --title "Add Package" \
            --extra-button --extra-label "Go Back" \
            --inputbox "Enter package name" "$HEIGHT" "$WIDTH" --stdout)
        local status=$?
        [[ $status -eq 3 ]] && show_package_menu && return
        [[ $status -eq 1 ]] && clear && exit 0
        [[ -z "${package// /}" ]] && continue
        if ! validate_package_exists "$package"; then continue; fi
        local data; data=$(jq '.' "$PACKAGES_JSON" 2>/dev/null || printf '{}')
        local category
        category=$(dialog --title "Choose Category" \
            --extra-button --extra-label "Go Back" \
            --cancel-label "Exit" \
            --menu "Select a category" "$HEIGHT" "$WIDTH" 0 \
            1 "Base" \
            2 "Dev" \
            3 "Utility" \
            2>&1 >/dev/tty)
        local cat_status=$?
        [[ $cat_status -eq 3 ]] && show_package_menu && return
        [[ $cat_status -eq 1 ]] && clear && exit 0
        local updated
        case "$category" in
            1) updated=$(jq --arg var "$package" '.base += [$var]' <<< "$data") ;;
            2) updated=$(jq --arg var "$package" '.dev += [$var]' <<< "$data") ;;
            3) updated=$(jq --arg var "$package" '.utility += [$var]' <<< "$data") ;;
        esac
        printf '%s\n' "$updated" > "$PACKAGES_JSON"
        dialog --title "Package Added" --msgbox "Package '$package' added successfully." "$HEIGHT" "$WIDTH"
    done
}

install_packages() {
    local category
    category=$(dialog --title "Install Category" \
        --extra-button --extra-label "Go Back" \
        --cancel-label "Exit" \
        --menu "Choose category" "$HEIGHT" "$WIDTH" 0 \
        1 "Base" \
        2 "Dev" \
        3 "Utility" \
        2>&1 >/dev/tty)
    local status=$?
    [[ $status -eq 3 ]] && show_package_menu && return
    [[ $status -eq 1 ]] && clear && exit 0
    local key
    case "$category" in
        1) key="base" ;;
        2) key="dev" ;;
        3) key="utility" ;;
    esac
    mapfile -t pkg_array < <(jq -r ".${key}[]" "$PACKAGES_JSON")
    [[ ${#pkg_array[@]} -eq 0 ]] && dialog --title "Install Packages" --msgbox "No packages found in $key" "$HEIGHT" "$WIDTH" && return

    run_with_sudo true

    local new_installed=()
    for pkg in "${pkg_array[@]}"; do
        if ! pacman -Qi "$pkg" &>/dev/null; then
            new_installed+=("$pkg")
        fi
    done

    if [[ ${#new_installed[@]} -eq 0 ]]; then
        dialog --title "Install Packages" --msgbox "All packages already installed." "$HEIGHT" "$WIDTH"
        return
    fi

    rm -f "$TMP_OUTPUT"

    (
        total=${#new_installed[@]}
        current=0

        echo "XXX"
        echo "Preparing package installation..."
        echo "XXX"
        echo "0"

        printf '%s\n' "$SUDO_PASS" | sudo -S pacman -Sy >>"$TMP_OUTPUT" 2>&1 || true
        echo "10"
        for pkg in "${new_installed[@]}"; do
            current=$((current + 1))
            progress=$((10 + (current * 80 / total)))

            echo "XXX"
            echo "Installing $pkg ($current/$total)..."
            echo "XXX"
            echo "$progress"

            if ! install_package "$pkg"; then
                echo "XXX"
                echo "Failed to install $pkg"
                echo "XXX"
                continue
            fi
        done

        echo "100"
    ) | dialog --title "Installing Packages" --gauge "Please wait..." "$HEIGHT" "$WIDTH" 0
    if grep -q -i -e "error" -e "warning" -e "failed" "$TMP_OUTPUT"; then
        dialog --title "Installation Log" --textbox "$TMP_OUTPUT" "$HEIGHT" "$WIDTH"
    else
        dialog --title "Installation Complete" --msgbox "All packages installed successfully." "$HEIGHT" "$WIDTH"
    fi
}


delete_package() {
    local data; data=$(jq '.' "$PACKAGES_LOCK")
    local category
    category=$(dialog --title "Delete Package - Select Category" \
        --cancel-label "Exit" \
        --menu "Choose category to delete from" "$HEIGHT" "$WIDTH" 0 \
        1 "Base" \
        2 "Dev" \
        3 "Utility" \
        2>&1 >/dev/tty)
    [[ $? -eq 1 ]] && clear && exit 0
    local key pkglist
    case "$category" in
        1) key="base" ;;
        2) key="dev" ;;
        3) key="utility" ;;
    esac
    mapfile -t pkglist < <(jq -r ".${key}[]" <<< "$data")
    if [[ ${#pkglist[@]} -eq 0 ]]; then
        dialog --title "Delete Package" --msgbox "No packages in $key to delete" "$HEIGHT" "$WIDTH"
        return
    fi
    local dialog_args=()
    for pkg in "${pkglist[@]}"; do
        dialog_args+=("$pkg" "$pkg")
    done
    local del_pkg
    del_pkg=$(dialog --title "Delete Package from $key" \
        --cancel-label "Cancel" \
        --menu "Select package to delete" "$HEIGHT" "$WIDTH" 0 \
        "${dialog_args[@]}" \
        2>&1 >/dev/tty)
    [[ $? -ne 0 ]] && return
    local updated
    updated=$(jq --arg p "$del_pkg" ".${key} |= map(select(. != \$p))" <<< "$data")
    printf '%s\n' "$updated" > "$PACKAGES_JSON"
    dialog --title "Package Removed" --msgbox "'$del_pkg' removed from $key in packages.json" "$HEIGHT" "$WIDTH"
}

update_lock() {
    if [[ ! -f "$PACKAGES_JSON" ]]; then
        dialog --title "Update Lock" --msgbox "packages.json not found" "$HEIGHT" "$WIDTH"
        return
    fi
    cp "$PACKAGES_JSON" "$PACKAGES_LOCK"
    dialog --title "Update Lock" --msgbox "Lock file updated successfully" "$HEIGHT" "$WIDTH"
}
clean_packages() {
    [[ -f "$PACKAGES_JSON" && -f "$PACKAGES_LOCK" ]] || {
        dialog --title "Clean Packages" --msgbox "Missing package.json or lockfile" "$HEIGHT" "$WIDTH"
        return
    }

    local json_pkgs lock_pkgs
    json_pkgs=$(jq -r '.[] | .[]' "$PACKAGES_JSON")
    lock_pkgs=$(jq -r '.[] | .[]' "$PACKAGES_LOCK")
    local to_remove=()
    while IFS= read -r pkg; do
        if ! grep -qxF "$pkg" <<< "$lock_pkgs"; then
            to_remove+=("$pkg")
        fi
    done <<< "$json_pkgs"

    if [[ ${#to_remove[@]} -eq 0 ]]; then
        dialog --title "Clean Packages" --msgbox "No packages to clean." "$HEIGHT" "$WIDTH"
        return
    fi

    dialog --title "Confirm Removal" \
        --yesno "The following packages will be removed:\n\n$(printf '%s\n' "${to_remove[@]}")\n\nProceed?" \
        "$HEIGHT" "$WIDTH" || return

    run_with_sudo true

    (
        echo "20"
        echo "XXX"
        echo "Removing packages..."
        echo "XXX"

        if [[ "$PACKAGE_MANAGER" == "paru" ]]; then
            printf '%s\n' "$SUDO_PASS" | sudo -S paru -Rsn --noconfirm "${to_remove[@]}" >>"$TMP_OUTPUT" 2>&1 || true
        else
            printf '%s\n' "$SUDO_PASS" | sudo -S pacman -Rsn --noconfirm "${to_remove[@]}" >>"$TMP_OUTPUT" 2>&1 || true
        fi
        echo "60"
        echo "XXX"
        echo "Cleaning package cache..."
        echo "XXX"
        if [[ "$PACKAGE_MANAGER" == "paru" ]]; then
            printf '%s\n' "$SUDO_PASS" | sudo -S paru -Scc --noconfirm >>"$TMP_OUTPUT" 2>&1
        else
            printf '%s\n' "$SUDO_PASS" | sudo -S pacman -Scc --noconfirm >>"$TMP_OUTPUT" 2>&1
        fi
        echo "80"

        echo "XXX"
        echo "Updating packages.json..."
        echo "XXX"
        local updated_json=$(jq --argjson to_remove "$(printf '%s\n' "${to_remove[@]}" | jq -R . | jq -s .)" '
            def remove_pkgs($arr):
                . as $orig | reduce $arr[] as $pkg ($orig;
                    .[] |= map(select(. != $pkg))
                );
            remove_pkgs($to_remove)
        ' "$PACKAGES_JSON")

        printf '%s\n' "$updated_json" > "$PACKAGES_JSON"
        echo "100"
    ) | dialog --title "Cleaning Packages" --gauge "Please wait..." "$HEIGHT" "$WIDTH" 0

    dialog --title "Cleaning Complete" \
        --msgbox "Successfully removed:\n\n$(printf '%s\n' "${to_remove[@]}")\n\npackages.json has been updated." \
        "$HEIGHT" "$WIDTH"
}
init_packages() {
    mkdir -p "$DOTFILES_DIR"

    local messages=()

    if [[ -f "$PACKAGES_JSON" ]]; then
        messages+=("packages.json already exists")
    else
        cat > "$PACKAGES_JSON" <<EOF
{
  "base": ["git", "neovim", "tmux"],
  "dev": ["python", "nodejs", "rustup"],
  "utility": ["htop", "fzf", "ripgrep"]
}
EOF
        messages+=("Created packages.json")
    fi

    if [[ -f "$PACKAGES_LOCK" ]]; then
        messages+=("packages-lock.json already exists")
    else
        if [[ -f "$PACKAGES_JSON" ]]; then
            cp "$PACKAGES_JSON" "$PACKAGES_LOCK"
            messages+=("Created packages-lock.json from packages.json")
        else
            messages+=("Could not create lockfile - packages.json missing")
        fi
    fi

    dialog --title "Initialize Packages" \
        --msgbox "$(printf '%s\n' "${messages[@]}")" \
        "$HEIGHT" "$WIDTH"
}
link_dotfiles() {
    mkdir -p "$CONFIG_DIR"
    local output; output=$(mktemp)
    for item in "$DOTFILES_DIR/dotfiles"/.* "$DOTFILES_DIR/dotfiles"/*; do
        [[ -e "$item" && ! "$(basename "$item")" =~ ^\.{1,2}$ ]] || continue
        local filename; filename=$(basename "$item")
        local target="$CONFIG_DIR/$filename"
        [[ -e "$target" ]] && rm -rf "$target"
        ln -s "$item" "$target"
        printf "├── %s -> %s\n" "$target" "$item" >> "$output"
    done
    dialog --title "Linked Dotfiles" --textbox "$output" "$HEIGHT" "$WIDTH"
    rm -f "$output"
}

dialog_box() {
    dialog --title "Linux system" --msgbox "System manager by csode" 10 40
    while true; do
        if ! show_main_menu; then break; fi
    done
}

main

