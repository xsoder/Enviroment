#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

WIDTH=80
HEIGHT=40
CONFIG_DIR="$HOME/.config"
DOTFILES_DIR="$HOME/devenv"
PACKAGE_MANAGER="paru"
PACKAGES_JSON="$DOTFILES_DIR/packages.json"
PACKAGES_LOCK="$DOTFILES_DIR/packages-lock.json"
SUDO_PASS=""
TMP_OUTPUT="/tmp/package-install-output.log"
main() {
    trap 'cleanup' INT TERM
    dialog_box
    clear
    exit 0
}

cleanup() {
    clear
    printf "Script interrupted or terminated\n" >&2
    exit 1
}

get_sudo_password() {
    local pass
    while true; do
        pass=$(dialog --insecure --passwordbox "Enter sudo password" "$HEIGHT" "$WIDTH" 2>&1 >/dev/tty)
        if [[ -z "${pass// /}" ]]; then
            dialog --title "Authentication Failed" --msgbox "Password required" "$HEIGHT" "$WIDTH"
            clear
            exit 1
        fi
        if echo "$pass" | sudo -S -v &>/dev/null; then
            export SUDO_PASS="$pass"
            break
        else
            dialog --title "Authentication Failed" --msgbox "Incorrect password. Try again." "$HEIGHT" "$WIDTH"
        fi
    done
}

run_with_sudo() {
    if [[ -z "${SUDO_PASS:-}" ]]; then
        get_sudo_password
    fi
    printf '%s\n' "$SUDO_PASS" | sudo -S "$@"
}

validate_package_exists() {
    local name="$1"
    if pacman -Si "$name" &>/dev/null; then
        return 0
    fi
    if command -v paru &>/dev/null && paru -Si "$name" &>/dev/null; then
        return 0
    fi
    dialog --title "Validation Failed" --msgbox "Package '$name' not found in any repositories." "$HEIGHT" "$WIDTH"
    return 1
}

install_package() {
    local pkg="$1"
    if pacman -Qi "$pkg" &>/dev/null; then
        echo "Package $pkg already installed - skipping" >> "$TMP_OUTPUT"
        return 0
    fi

    echo "Installing $pkg..." >> "$TMP_OUTPUT"
    if command -v "$PACKAGE_MANAGER" &>/dev/null; then
        printf '%s\n' "$SUDO_PASS" | sudo -S "$PACKAGE_MANAGER" -S --needed --noconfirm "$pkg" >> "$TMP_OUTPUT" 2>&1
    else
        printf '%s\n' "$SUDO_PASS" | sudo -S pacman -S --needed --noconfirm "$pkg" >> "$TMP_OUTPUT" 2>&1
    fi
}

install_packages() {
    local category
    category=$(dialog --title "Install Category" \
        --extra-button --extra-label "Go Back" \
        --cancel-label "Exit" \
        --menu "Choose category" "$HEIGHT" "$WIDTH" 0 \
        1 "Base" \
        2 "Dev" \
        3 "Utility" \
        4 "All" \
        2>&1 >/dev/tty)

    local status=$?
    [[ $status -eq 3 ]] && show_package_menu && return
    [[ $status -eq 1 ]] && clear && exit 0

    local pkg_array=()
    case "$category" in
        1) mapfile -t pkg_array < <(jq -r '.base[]' "$PACKAGES_JSON") ;;
        2) mapfile -t pkg_array < <(jq -r '.dev[]' "$PACKAGES_JSON") ;;
        3) mapfile -t pkg_array < <(jq -r '.utility[]' "$PACKAGES_JSON") ;;
        4) mapfile -t pkg_array < <(jq -r '.base[], .dev[], .utility[]' "$PACKAGES_JSON" | sort -u) ;;
    esac

    [[ ${#pkg_array[@]} -eq 0 ]] && dialog --title "Install Packages" --msgbox "No packages found in selected category." "$HEIGHT" "$WIDTH" && return

    run_with_sudo true

    local new_installed=()
    for pkg in "${pkg_array[@]}"; do
        if ! pacman -Qi "$pkg" &>/dev/null; then
            new_installed+=("$pkg")
        fi
    done

    if [[ ${#new_installed[@]} -eq 0 ]]; then
        dialog --title "Install Packages" --msgbox "All packages already installed." "$HEIGHT" "$WIDTH"
        return
    fi

    rm -f "$TMP_OUTPUT"
    echo "Starting package installation..." > "$TMP_OUTPUT"

    (
        total=${#new_installed[@]}
        current=0

        echo "XXX"
        echo "Preparing package installation..."
        echo "XXX"
        echo "0"

        for pkg in "${new_installed[@]}"; do
            current=$((current + 1))
            progress=$((current * 100 / total))

            echo "XXX"
            echo "Installing $pkg ($current/$total)..."
            echo "XXX"
            echo "$progress"

            install_package "$pkg"
        done

        echo "100"
    ) | dialog --title "Installing Packages" --gauge "Please wait..." "$HEIGHT" "$WIDTH" 0

    dialog --title "Installation Log" --textbox "$TMP_OUTPUT" "$HEIGHT" "$WIDTH"
    dialog --title "Installation Complete" --msgbox "Package installation process finished." "$HEIGHT" "$WIDTH"
}
show_main_menu() {
    local choice
    choice=$(dialog --title "Linux system" \
        --cancel-label "Exit" \
        --menu "Choose an option" "$HEIGHT" "$WIDTH" 0 \
        1 "Packages" \
        2 "Symlink dotfiles" \
        3 "Initialize packages.json" \
        2>&1 >/dev/tty)
    local status=$?
    if [[ $status -eq 1 ]]; then clear; exit 0; fi
    case "$choice" in
        1) show_package_menu ;;
        2) link_dotfiles ;;
        3) init_packages ;;
    esac
}

show_package_menu() {
    local option
    option=$(dialog --title "Package Menu" \
        --extra-button --extra-label "Go Back" \
        --cancel-label "Exit" \
        --menu "Choose a package operation" "$HEIGHT" "$WIDTH" 0 \
        1 "Add packages" \
        2 "Install packages" \
        3 "Delete packages" \
        4 "Update lockfile" \
        5 "Clean system" \
        2>&1 >/dev/tty)
    local status=$?
    if [[ $status -eq 3 ]]; then show_main_menu; return; fi
    if [[ $status -eq 1 ]]; then clear; exit 0; fi
    case "$option" in
        1) add_package ;;
        2) install_packages ;;
        3) delete_package ;;
        4) update_lock ;;
        5) clean_packages ;;
    esac
}

add_package() {
    while true; do
        local package
        package=$(dialog --title "Add Package" \
            --extra-button --extra-label "Go Back" \
            --inputbox "Enter package name" "$HEIGHT" "$WIDTH" --stdout)
        local status=$?
        [[ $status -eq 3 ]] && show_package_menu && return
        [[ $status -eq 1 ]] && clear && exit 0
        [[ -z "${package// /}" ]] && continue
        if ! validate_package_exists "$package"; then continue; fi
        local data; data=$(jq '.' "$PACKAGES_JSON" 2>/dev/null || printf '{}')
        local category
        category=$(dialog --title "Choose Category" \
            --extra-button --extra-label "Go Back" \
            --cancel-label "Exit" \
            --menu "Select a category" "$HEIGHT" "$WIDTH" 0 \
            1 "Base" \
            2 "Dev" \
            3 "Utility" \
            2>&1 >/dev/tty)
        local cat_status=$?
        [[ $cat_status -eq 3 ]] && show_package_menu && return
        [[ $cat_status -eq 1 ]] && clear && exit 0
        local updated
        case "$category" in
            1) updated=$(jq --arg var "$package" '.base += [$var]' <<< "$data") ;;
            2) updated=$(jq --arg var "$package" '.dev += [$var]' <<< "$data") ;;
            3) updated=$(jq --arg var "$package" '.utility += [$var]' <<< "$data") ;;
        esac
        printf '%s\n' "$updated" > "$PACKAGES_JSON"
        dialog --title "Package Added" --msgbox "Package '$package' added successfully." "$HEIGHT" "$WIDTH"
    done
}

delete_package() {
    local data; data=$(jq '.' "$PACKAGES_LOCK")
    local category
    category=$(dialog --title "Delete Package - Select Category" \
        --cancel-label "Exit" \
        --menu "Choose category to delete from" "$HEIGHT" "$WIDTH" 0 \
        1 "Base" \
        2 "Dev" \
        3 "Utility" \
        2>&1 >/dev/tty)
    [[ $? -eq 1 ]] && clear && exit 0
    local key pkglist
    case "$category" in
        1) key="base" ;;
        2) key="dev" ;;
        3) key="utility" ;;
    esac
    mapfile -t pkglist < <(jq -r ".${key}[]" <<< "$data")
    if [[ ${#pkglist[@]} -eq 0 ]]; then
        dialog --title "Delete Package" --msgbox "No packages in $key to delete" "$HEIGHT" "$WIDTH"
        return
    fi
    local dialog_args=()
    for pkg in "${pkglist[@]}"; do
        dialog_args+=("$pkg" "$pkg")
    done
    local del_pkg
    del_pkg=$(dialog --title "Delete Package from $key" \
        --cancel-label "Cancel" \
        --menu "Select package to delete" "$HEIGHT" "$WIDTH" 0 \
        "${dialog_args[@]}" \
        2>&1 >/dev/tty)
    [[ $? -ne 0 ]] && return
    local updated
    updated=$(jq --arg p "$del_pkg" ".${key} |= map(select(. != \$p))" <<< "$data")
    printf '%s\n' "$updated" > "$PACKAGES_LOCK"
    dialog --title "Package Removed" --msgbox "'$del_pkg' removed from $key in packages-lock.json" "$HEIGHT" "$WIDTH"
}
update_lock() {
    if [[ ! -f "$PACKAGES_JSON" ]]; then
        dialog --title "Update Lock" --msgbox "packages.json not found" "$HEIGHT" "$WIDTH"
        return
    fi
    cp "$PACKAGES_JSON" "$PACKAGES_LOCK"
    dialog --title "Update Lock" --msgbox "Lock file updated successfully" "$HEIGHT" "$WIDTH"
}
clean_packages() {
    if [[ ! -f "$PACKAGES_JSON" || ! -f "$PACKAGES_LOCK" ]]; then
        dialog --title "Clean Packages" --msgbox "packages.json or packages-lock.json not found!" "$HEIGHT" "$WIDTH"
        return
    fi

    local installed declared to_remove
    declared=$(jq -r '.[] | .[]' "$PACKAGES_JSON" | sort -u)
    installed=$(jq -r '.[] | .[]' "$PACKAGES_LOCK" | sort -u)

    to_remove=$(comm -23 <(echo "$declared") <(echo "$installed"))

    if [[ -z "$to_remove" ]]; then
        dialog --title "Clean Packages" --msgbox "No unused packages to remove." "$HEIGHT" "$WIDTH"
        return
    fi

    dialog --title "Confirm Removal" --yesno "These packages are in packages.json but not in lockfile:\n\n$to_remove\n\nRemove them?" "$HEIGHT" "$WIDTH"
    local response=$?
    if [[ $response -ne 0 ]]; then
        return
    fi

    run_with_sudo true

    rm -f "$TMP_OUTPUT"
    (
        total=$(echo "$to_remove" | wc -l)
        current=0

        echo "XXX"
        echo "Removing unused packages..."
        echo "XXX"
        echo "0"

        while IFS= read -r pkg; do
            current=$((current + 1))
            progress=$((current * 100 / total))
            echo "XXX"
            echo "Uninstalling $pkg ($current/$total)..."
            echo "XXX"
            echo "$progress"

            if ! run_with_sudo pacman -Rns --noconfirm "$pkg" >>"$TMP_OUTPUT" 2>&1; then
                echo "XXX"
                echo "Failed to uninstall $pkg"
                echo "XXX"
                continue
            fi
        done <<< "$to_remove"

        echo "100"
    ) | dialog --title "Cleaning Packages" --gauge "Please wait..." "$HEIGHT" "$WIDTH" 0

    local orphaned
    orphaned=$(pacman -Qdtq 2>/dev/null || true)
    if [[ -n "$orphaned" ]]; then
        dialog --title "Remove Orphans" --yesno "Found orphaned packages:\n\n$orphaned\n\nRemove them?" "$HEIGHT" "$WIDTH"
        if [[ $? -eq 0 ]]; then
            echo "$orphaned" | xargs -r -n 1 sudo pacman -Rns --noconfirm
            dialog --title "Orphans Removed" --msgbox "Orphaned packages removed." "$HEIGHT" "$WIDTH"
        fi
    else
        dialog --title "No Orphans" --msgbox "No orphaned packages found." "$HEIGHT" "$WIDTH"
    fi

    dialog --title "Clean Package Cache" --yesno "Do you want to clear the package cache?\n(This runs 'pacman -Scc')" "$HEIGHT" "$WIDTH"
    if [[ $? -eq 0 ]]; then
        sudo pacman -Scc --noconfirm
        dialog --title "Cache Cleaned" --msgbox "Package cache cleaned." "$HEIGHT" "$WIDTH"
    fi

    dialog --title "Clean Complete" --msgbox "All cleanup steps completed." "$HEIGHT" "$WIDTH"
}

init_packages() {
    mkdir -p "$DOTFILES_DIR"

    local messages=()

    if [[ -f "$PACKAGES_JSON" ]]; then
        messages+=("packages.json already exists")
    else
        cat > "$PACKAGES_JSON" <<EOF
{
  "base": ["git", "neovim", "tmux"],
  "dev": ["python", "nodejs", "rustup"],
  "utility": ["htop", "fzf", "ripgrep"]
}
EOF
        messages+=("Created packages.json")
    fi

    if [[ -f "$PACKAGES_LOCK" ]]; then
        messages+=("packages-lock.json already exists")
    else
        if [[ -f "$PACKAGES_JSON" ]]; then
            cp "$PACKAGES_JSON" "$PACKAGES_LOCK"
            messages+=("Created packages-lock.json from packages.json")
        else
            messages+=("Could not create lockfile - packages.json missing")
        fi
    fi

    dialog --title "Initialize Packages" \
        --msgbox "$(printf '%s\n' "${messages[@]}")" \
        "$HEIGHT" "$WIDTH"
}
link_dotfiles() {
    mkdir -p "$CONFIG_DIR"
    local output; output=$(mktemp)
    for item in "$DOTFILES_DIR/dotfiles"/.* "$DOTFILES_DIR/dotfiles"/*; do
        [[ -e "$item" && ! "$(basename "$item")" =~ ^\.{1,2}$ ]] || continue
        local filename; filename=$(basename "$item")
        local target="$CONFIG_DIR/$filename"
        [[ -e "$target" ]] && rm -rf "$target"
        ln -s "$item" "$target"
        printf "├── %s -> %s\n" "$target" "$item" >> "$output"
    done
    dialog --title "Linked Dotfiles" --textbox "$output" "$HEIGHT" "$WIDTH"
    rm -f "$output"
}

dialog_box() {
    dialog --title "Linux system" --msgbox "System manager by csode" 10 40
    while true; do
        if ! show_main_menu; then break; fi
    done
}

main
