#!/usr/bin/bash

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

CONFIG_DIR="$HOME/.config"
DOTFILES_DIR="$HOME/devenv"
PACKAGE_MANAGER="paru"
SCRIPT_DIR="$HOME/scripts"
SCRIPT_REPO="https://github.com/xsoder/scripts.git"
PACKAGES_JSON="$DOTFILES_DIR/packages.json"
PACKAGES_LOCK="$DOTFILES_DIR/packages-lock.json"

info() { echo -e "${BLUE}[*]${NC} $1"; }
success() { echo -e "${GREEN}[✓]${NC} $1"; }
warning() { echo -e "${YELLOW}[!]${NC} $1"; }
error() { echo -e "${RED}[X]${NC} $1"; exit 1; }

update_lock() {
    cp "$PACKAGES_JSON" "$PACKAGES_LOCK"
    success "Lockfile updated"
}

clean_packages() {
    validate_packages
    [[ ! -f "$PACKAGES_LOCK" ]] && error "No lockfile found. Run 'update' first"

    info "Finding packages to remove..."
    local removed_packages=()

    while read -r category; do
        while read -r pkg; do
            if ! jq -e ".${category}[] | select(. == \"$pkg\")" "$PACKAGES_JSON" >/dev/null; then
                removed_packages+=("$pkg")
            fi
        done < <(jq -r ".${category}[]" "$PACKAGES_LOCK")
    done < <(jq -r 'keys[]' "$PACKAGES_LOCK")

    if [[ ${#removed_packages[@]} -eq 0 ]]; then
        success "No packages to remove"
        return
    fi

    warning "The following packages will be removed:"
    printf "  %s\n" "${removed_packages[@]}"
    read -rp "Continue? [y/N] " confirm
    [[ "$confirm" =~ ^[Yy]$ ]] || return

    if [[ "$PACKAGE_MANAGER" == "paru" ]]; then
        paru -Rsn --noconfirm "${removed_packages[@]}"
    else
        sudo pacman -Rsn --noconfirm "${removed_packages[@]}"
    fi

    update_lock
    success "Packages cleaned"
}

init_packages() {
    mkdir -p "$DOTFILES_DIR"

    if [[ ! -f "$PACKAGES_JSON" ]]; then
        cat > "$PACKAGES_JSON" <<EOF
{
  "base": ["git", "neovim", "tmux"],
  "dev": ["python", "nodejs", "rustup"],
  "utility": ["htop", "fzf", "ripgrep"]
}
EOF
        success "Created packages.json"
    else
        warning "packages.json already exists"
    fi

    if [[ ! -f "$PACKAGES_LOCK" ]]; then
        cp "$PACKAGES_JSON" "$PACKAGES_LOCK"
        success "Created packages.lock.json"
    else
        warning "packages.lock.json already exists"
    fi
}
edit_package(){
    info "Editing package json."
    nvim "$PACKAGES_JSON"
    success "Edited json file successfully"
}
check_jq() {
    if ! command -v jq &>/dev/null; then
        sudo pacman -Sy --noconfirm jq || error "Failed to install jq"
    fi
}

validate_packages() {
    check_jq
    [[ -f "$PACKAGES_JSON" ]] || error "Run '$0 init' first to create packages.json"
    jq empty "$PACKAGES_JSON" &>/dev/null || error "Invalid packages.json format"
}

get_categories() {
    jq -r 'keys[]' "$PACKAGES_JSON"
}

install_packages() {
    local category="$1"
    local packages=($(jq -r ".${category}[]" "$PACKAGES_JSON"))

    [[ ${#packages[@]} -eq 0 ]] && warning "No packages in $category" && return

    info "Installing ${#packages[@]} packages from $category..."
    if [[ "$PACKAGE_MANAGER" == "paru" ]]; then
        paru -S --needed --noconfirm "${packages[@]}"
    else
        sudo pacman -S --needed --noconfirm "${packages[@]}"
    fi
    success "Packages installed"
}

list_packages() {
    local category="$1"
    echo -e "\n${BLUE}Packages in ${category}:${NC}"
    echo "----------------------"

    while read -r pkg; do
        if pacman -Qi "$pkg" &>/dev/null; then
            echo -e "${GREEN}✓ $pkg${NC}"
        else
            echo -e "${RED}✗ $pkg${NC}"
        fi
    done < <(jq -r ".${category}[]" "$PACKAGES_JSON")
    echo "----------------------"
}

clone_scripts() {
    [[ -d "$SCRIPT_DIR" ]] && rm -rf "$SCRIPT_DIR"
    git clone "$SCRIPT_REPO" "$SCRIPT_DIR" && success "Scripts cloned"
}

copy_dotfiles() {
    mkdir -p "$CONFIG_DIR"
    for item in "$DOTFILES_DIR"/dotfiles/*; do
        [[ -e "$item" ]] || continue
        filename="$(basename "$item")"
        target="$CONFIG_DIR/$filename"
        [[ -e "$target" ]] && rm -rf "$target"
        cp -r "$item" "$target"
    done
    success "Dotfiles copied"
}

link_dotfiles() {
    mkdir -p "$CONFIG_DIR"
    for item in "$DOTFILES_DIR"/dotfiles/*; do
        [[ -e "$item" ]] || continue
        filename="$(basename "$item")"
        target="$CONFIG_DIR/$filename"
        [[ -e "$target" ]] && rm -rf "$target"
        ln -s "$item" "$target"
    done
    success "Symlinks created"
}

case "$1" in
    edit)
        edit_package ;;
    init)
        init_packages ;;
    update)
        validate_packages
        update_lock ;;
    clean)
        clean_packages ;;
    install)
        validate_packages
        [[ -z "$2" ]] && error "Specify category: $(get_categories | tr '\n' ' ')"
        install_packages "$2" ;;
    list)
        validate_packages
        [[ -z "$2" ]] && error "Specify category: $(get_categories | tr '\n' ' ')"
        list_packages "$2" ;;
    scripts)
        clone_scripts ;;
    copy)
        copy_dotfiles ;;
    link)
        link_dotfiles ;;
    *)
        echo -e "\n${BLUE}Commands:${NC}"
        echo "  init       - Initialize packages configuration"
        echo "  install    - Install packages from category"
        echo "  list       - List packages in category"
        echo "  scripts    - Clone scripts repository"
        echo "  copy       - Copy dotfiles"
        echo "  link       - Create symlinks"
        echo "  edit       - Edit the package json"
        echo "  clean      - Removes unused packages by comparing them with the packages-lock.json"
        echo "  update     - Update the packages-lock.json by the new packages.json"

        if [[ -f "$PACKAGES_JSON" ]]; then
            echo -e "\n${BLUE}Available categories:${NC}"
            get_categories | while read -r cat; do echo "  - $cat"; done
        else
            echo -e "\n${YELLOW}Run 'init' first to create packages.json${NC}"
        fi
        exit 1
        ;;
esac
